<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Micro:bit Rhythm Game</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
</head>
<body>
<h2>Micro:bit Rhythm Game</h2>
<button id="connectBtn">Connect Micro:bit via USB</button>
<input type="file" id="audioUpload" accept="audio/*">
<p>Estimated BPM: <span id="bpmDisplay">0</span></p>
<p>Score: <span id="scoreDisplay">0</span></p>

<script>
let port, reader; //Micro:bit WebUSB variables
let notes = [];
let score = 0;
let beatData = null;
let beatIndex = 0;
let startTime = 0;

// Web Audio
const audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // initialize Web audio API
let source = null;

// Beat sync
let bpm = 120;
let secondsPerBeat = 0.5;
let nextBeatTime = 0;
let noteTravelTime = 2; // seconds for note to fall from top to hit line

// Game environment setup through p5.js
function setup() {
  createCanvas(600, 400);
  textSize(20);
}

function draw() {
  background(30);

  if (source && beatData) {
    const currentTime = audioCtx.currentTime - startTime;

    // Spawn notes from JSON
    while (beatIndex < beatData.notes.length &&
      currentTime >= beatData.notes[beatIndex].time
    ) {
      const beat = beatData.notes[beatIndex];
      const x = beat.type === "left" ? random(100, 250) : random(350, 500);
      const speed = (height - 50) / noteTravelTime; //note speed calculation
      notes.push({ x, y: 0, type: beat.type, speed });
      beatIndex++;
    }
  }
  // … rest unchanged …}  

  // Generate and move notes
  for (let i = notes.length-1; i >= 0; i--) {
    notes[i].y += notes[i].speed * (deltaTime / 1000);

    fill(notes[i].type === "left" ? "blue" : "green");
    ellipse(notes[i].x, notes[i].y, 30, 30);

    if (notes[i].y > height) {
      notes.splice(i,1);
    }
  }

  // Hit line
  stroke(255,0,0);
  line(0,height-50,width,height-50);

  fill(255);
  text("Score: " + score, 20, 30);
  document.getElementById("scoreDisplay").innerText = score;
}

// --- Micro:bit USB ---
document.getElementById("connectBtn").onclick = async () => {
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 }); //Micro:bit default serial connection rate
    const decoder = new TextDecoderStream();
    port.readable.pipeTo(decoder.writable);
    reader = decoder.readable.getReader();
    readLoop();
  } catch (err) {
    console.error("Serial error:", err);
  }
};

//Continuously reads output from Micro:bit and passes it to handleInput()
async function readLoop() {
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    if (value) handleInput(value.trim());
  }
}

//Checks if micro:bit sent 'A' or 'B' and performs the suitable logic
function handleInput(input) {
  for (let i = notes.length-1; i >=0; i--) {
    if (input === "A" && notes[i].type === "left" && Math.abs(notes[i].y - (height - 50)) < 30) {
      score += 100;
      notes.splice(i,1);
      break;
    }
    if (input === "B" && notes[i].type === "right" && Math.abs(notes[i].y - (height - 50)) < 30) {
      score += 100;
      notes.splice(i,1);
      break;
    }
    if (input === "SHAKE") {
      score += 50; // or trigger a bonus effect
    }

  }
}

// --- Audio upload ---
const fileInput = document.getElementById("audioUpload");
fileInput.addEventListener("change", async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
  }

  const arrayBuffer = await file.arrayBuffer(); //converts file to an array buffer
  const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer); //decodes audio file to an audio buffer for furthur analyzation

  // Estimate BPM
  bpm = estimateBPM(audioBuffer);
  secondsPerBeat = 60 / bpm;
  document.getElementById("bpmDisplay").innerText = Math.round(bpm);

  // Generate JSON beatData (creates rythm map to decide which side note appers and at what timestamp)
  beatData = { notes: [] };
  const beatSpacing = 2; // spawn every 2 beats
  for (let i = 0; i * secondsPerBeat * beatSpacing < audioBuffer.duration; i++) {
    beatData.notes.push({
      time: i * secondsPerBeat * beatSpacing,
      type: Math.random() < 0.5 ? "left" : "right"
    });
  }

  console.log("Generated beatData", beatData);

  beatIndex = 0;
  notes = [];

  // Play audio
  if (source) source.disconnect();
  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(audioCtx.destination);
  source.start();
  startTime = audioCtx.currentTime;
});

// --- Simple BPM estimation ---
function estimateBPM(buffer) {
  const data = buffer.getChannelData(0); // mono
  const sampleRate = buffer.sampleRate;
  const frameSize = 1024;
  const hopSize = 512;
  let energies = [];

  // Compute short-time energy
  for (let i = 0; i < data.length - frameSize; i += hopSize) {
    let sum = 0;
    for (let j = 0; j < frameSize; j++) sum += data[i+j]*data[i+j];
    energies.push(sum);
  }

  // Detect peaks
  let peakTimes = [];
  for (let i = 1; i < energies.length-1; i++) {
    if (energies[i] > energies[i-1] && energies[i] > energies[i+1] && energies[i] > 0.01) {
      peakTimes.push(i*hopSize/sampleRate);
    }
  }

  // Compute inter-beat intervals
  let intervals = [];
  for (let i = 1; i < peakTimes.length; i++) {
    intervals.push(peakTimes[i]-peakTimes[i-1]);
  }

  if (intervals.length === 0) return 120;

  let histogram = {};
  intervals.forEach(interval => {
    let rounded = Math.round(interval * 10) / 10;
    histogram[rounded] = (histogram[rounded] || 0) + 1;
  });
  let dominantInterval = parseFloat(Object.entries(histogram).sort((a,b) => b[1]-a[1])[0][0]);
  const estimatedBPM = 60 / dominantInterval;
  return Math.min(Math.max(estimatedBPM, 90), 140);
}
</script>
</body>
</html>
