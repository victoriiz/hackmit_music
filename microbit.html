<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Micro:bit Rhythm Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
</head>
<body>
<h2>Micro:bit Rhythm Game</h2>
<button id="connectBtn">Connect Micro:bit via USB</button>
<input type="file" id="audioUpload" accept="audio/*">
<p>Score: <span id="scoreDisplay">0</span></p>
<audio id="song" controls></audio>

<script>
let port, reader;
let activeNotes = [];
let score = 0;

// Beat detection
let beatTimes = [];
let beatIndex = 0;

// Web Audio setup
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let audioBuffer = null;
let source = null;

// p5.js setup
function setup() {
  createCanvas(600, 400);
  textSize(20);
}

// Draw loop
function draw() {
  background(30);

  if (source && beatTimes.length > 0) {
    const currentTime = audioCtx.currentTime - source.startTime;

    // Spawn notes on precomputed beats
    while (beatIndex < beatTimes.length && currentTime >= beatTimes[beatIndex]) {
      const type = Math.random() < 0.5 ? "left" : "right";
      const x = type === "left" ? random(100, 250) : random(350, 500);
      activeNotes.push({x: x, y: 0, type: type});
      beatIndex++;
    }
  }

  // Draw notes
  for (let i = activeNotes.length-1; i >=0; i--) {
    activeNotes[i].y += 3;
    fill(activeNotes[i].type === "left" ? "blue" : "green");
    ellipse(activeNotes[i].x, activeNotes[i].y, 30, 30);

    if (activeNotes[i].y > height-50) {
      activeNotes.splice(i,1);
    }
  }

  // Hit line
  stroke(255,0,0);
  line(0,height-50,width,height-50);

  fill(255);
  text("Score: " + score, 20, 30);
  document.getElementById("scoreDisplay").innerText = score;
}

// --- Micro:bit USB connection ---
document.getElementById("connectBtn").onclick = async () => {
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 115200 });

    const decoder = new TextDecoderStream();
    port.readable.pipeTo(decoder.writable);
    reader = decoder.readable.getReader();
    readLoop();
  } catch (err) {
    console.error("Serial error:", err);
  }
};

async function readLoop() {
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    if (value) handleInput(value.trim());
  }
}

function handleInput(input) {
  if (input === "A") {
    for (let i = activeNotes.length-1; i >=0; i--) {
      if (activeNotes[i].type === "left" && abs(activeNotes[i].y - (height-50)) < 30) {
        score += 100;
        activeNotes.splice(i,1);
        break;
      }
    }
  }
  if (input === "B") {
    for (let i = activeNotes.length-1; i >=0; i--) {
      if (activeNotes[i].type === "right" && abs(activeNotes[i].y - (height-50)) < 30) {
        score += 100;
        activeNotes.splice(i,1);
        break;
      }
    }
  }
}

// --- Audio file upload & preprocessing ---
const fileInput = document.getElementById("audioUpload");
fileInput.addEventListener("change", async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  const arrayBuffer = await file.arrayBuffer();
  audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

  // Run beat detection preprocessing
  beatTimes = detectBeats(audioBuffer);
  beatIndex = 0;

  // Play audio
  if (source) source.disconnect();
  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(audioCtx.destination);
  source.start();
  source.startTime = audioCtx.currentTime; // custom property for timing
});

// --- Simple beat detection function ---
function detectBeats(buffer) {
  const channelData = buffer.getChannelData(0); // mono
  const sampleRate = buffer.sampleRate;
  const frameSize = 1024;
  const hopSize = 512;
  const energies = [];

  // Calculate short-time energy
  for (let i = 0; i < channelData.length - frameSize; i += hopSize) {
    let sum = 0;
    for (let j = 0; j < frameSize; j++) {
      sum += channelData[i+j] * channelData[i+j];
    }
    energies.push(sum);
  }

  // Detect peaks in energy
  const beatTimes = [];
  for (let i = 1; i < energies.length-1; i++) {
    if (energies[i] > energies[i-1] && energies[i] > energies[i+1] && energies[i] > 0.001) {
      beatTimes.push(i * hopSize / sampleRate);
    }
  }
  return beatTimes;
}
</script>
</body>
</html>
